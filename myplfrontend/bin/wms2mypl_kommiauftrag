#!/usr/bin/env python
# encoding: utf-8
"""
Empfängt offene Kommissionierbelege aus einer message queue, legt einen Lieferscheinsatz
(==Komissionierbeleg) in Django an und schreibt die Daten in den kernelE.

Created by Lars Ronge, Maximillian Dornseif on 2007-12-07, 2007-12-19.
Rewritten by Maximillian Dornseif 2008-12 and 2010-01
Copyright (c) 2007, 2008, 2010 HUDORA GmbH.
"""

from cs.masterdata import article
import cs.messaging
from cs.messaging.journal import write_journal
from myplfrontend.kernelapi import Kerneladapter
from myplfrontend.tools import get_versandtermin
import optparse
import signal
import sys
import time
import logging

LOGGER = logging.getLogger("wms2mypl_kommiauftrag")

process_messages = True


def export_kommi_to_kernel(doc):
    """Pushes Kommiauftrag into kernel."""
    global options
    kommiauftragsnr = doc['kommiauftragsnr']
    # softmschein = husoftm.lieferscheine.Kommibeleg(kommiauftragsnr)
    
    attributes = {'auftragsnummer': kommiauftragsnr,
                  # TODO: remove liefertermin from Kernel
                  'liefertermin': kommibeleg.liefer_date.strftime("%Y-%m-%d"),
                  # FIXME diese attribute scheint es nicht zu geben im SoftM Lieferschein/Kommibeleg
                  #'anliefertermin_min': softmschein.anliefertermin_min.strftime("%Y-%m-%d"),
                  #'anliefertermin_max': softmschein.anliefertermin_max.strftime("%Y-%m-%d"),
                  'versandtermin': get_versandtermin(doc['anliefertermin'], doc['land']),
                  'kundenname': doc['name1'],
                  'land': doc['land'],
                  'plz': doc['plz'],
                  'art': doc['auftragsart'],
                  'fixtermin': doc.get('fixtermin', False),
                  # TODO: Was ist mit den folgenden Attributen?
                  #'anbruch': kommibeleg.anbruch,
                  #'kep': kommibeleg.kep,
                  #'packstuecke': kommibeleg.packstuecke,
                  #'paletten': kommibeleg.paletten,
                  #'picks': kommibeleg.picks,
                  #'versandpaletten': kommibeleg.versandpaletten,
                  #'max_packstueck_gewicht': kommibeleg.max_packstueck_gewicht,
                 }
    
    orderlines = []
    total_weight, total_volume = 0., 0.
    for position in doc['positionen']:
        produktpass = article.eap(position['artnr'])
        total_volume += position['menge'] * produktpass['package_volume_liter']
        total_weight += position['menge'] * produktpass['package_weight']
        pos_params = {"auftragsposition": position['kommissionierbeleg_position'], "gewicht": produktpass['package_weight']}
        orderlines.append((position['menge'], position['artnr'], pos_params))
    
    if not options.dry_run:
        Kerneladapter().insert_pipeline((
            kommiauftragsnr, orderlines,
            3, # Wir verwenden die mittlere Priorität (Werte von 1 bis 5)
            doc['kundennr'], # Warenempfänger
            total_weight, total_volume, attributes))


def handle_message(message):
    """Callback function used by channel.basic_consume for adding 'Warenzugang' to myPL."""
    global options
    
    doc = cs.messaging.decode(message.body)
    if export_kommi_to_kernel(doc):
        write_journal(doc, options.log)
        message.channel.basic_ack(message.delivery_tag)


def cancel_processing():
    """ Stop consuming messages from RabbitMQ """
    global process_messages, channel

    process_messages = False
    LOGGER.info("Exiting")
    # Tell the channel you dont want to consume anymore
    for consumer_tag in consumer_tags:
        channel.basic_cancel(consumer_tag)


def main():
    """Setup message consuming."""
    global channel, consumer_tags, options
    consumer_tags = []

    parser = optparse.OptionParser()
    parser.version = "%%prog"
    parser.description = 'Erzeugt Kommissionerauftraege (Provpipeline Entries) im kernelE'
    parser.set_usage('usage: %prog [options]')
    parser.add_option('--lager', type="int", help='Lager, das bearbeitet werden soll')
    parser.add_option('--in', dest="in_queues", action='append',
                      help='Name der Queue, aus der gelesen werden soll. Wird diese Parameter mehrfach '
                      +'angegeben, wird aus mehreren Queues gelesen. Beispiel --in=erp.ic-wms.warenzugang.')
    parser.add_option('--log', default='/var/log/wms2mypl_kommiauftrag.log',
                      help='Wohin sollen die Nachrichten protokolliert werden? [%default]')
    parser.add_option('--quiet', action='store_true', help='Uebliche Ausgaben unterdruecken')
    parser.add_option('--debug', action='store_true', help='Debugging Informationen ausgeben')
    parser.add_option('--dry-run', action='store_true', help='Keine Nachrichten absenden und loeschen')
    options, args = parser.parse_args()
    if args:
        parser.error("incorrect number of arguments")
    if not options.lager:
        parser.error("'--lager' nicht gesetzt")
    if not options.in_queues:
        parser.error("'--in' nicht gesetzt")

    channel = None
    for qname in options.in_queues:
        inqueuename = "%s#%s" % (qname, options.lager)
        channel = cs.messaging.setup_queue(inqueuename, channel=channel, durable=True)
        consumer_tags.append(channel.basic_consume(queue=inqueuename, callback=handle_message))

    # Install signal handlers
    signal.signal(signal.SIGTERM, lambda signum, stack_frame: cancel_processing())
    signal.signal(signal.SIGINT, lambda signum, stack_frame: cancel_processing())

    if options.debug:
        LOGGER.setLevel(logging.DEBUG)
    elif options.quiet:
        LOGGER.setLevel(logging.ERROR)
    else:
        LOGGER.setLevel(logging.INFO)

    LOGGER.info("Waiting for messages ...")

    last_requeue = time.time()
    while process_messages:
        # Wait for a message and wait for `handle_message` callback beeing called
        channel.wait()
        if time.time() - last_requeue > 3600:
            # every 3600 seconds Request non-acknowledged messages to be re-delivered
            channel.basic_recover(requeue=True)
            last_requeue = time.time()
    
    channel.close()
    return 0


if __name__ == '__main__':
    sys.exit(main())
