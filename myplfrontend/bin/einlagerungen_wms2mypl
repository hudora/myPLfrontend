#!/usr/bin/env python
# encoding: utf-8
"""
Uebernimmt Warenzugangsmeldungen für Lager 100 aus einer Nachrichtenschlange und lagert diese im
myPL ein (EINLAG). Erstellt ausserdem eine Warenbewegung im myPL an einen geeigneten Platz und
erzeugt eine Palettenfahne.

Created by Lars Ronge on 2007-12-12.
Rewritten by Maximillian Dornseif 2008-12, 2009-12
Copyright (c) 2007-2010 HUDORA GmbH.
"""

# From http://superjared.com/entry/django-and-crontab-best-friends/
from django.core.management import setup_environ
import settings
setup_environ(settings)

from mypl.kernel import Kerneladapter
import cs.messaging as messaging
import cs.zwitscher
import optparse
import produktpass.models
import signal
import simplejson as json
import sys
import cs.masterdata.article

process_messages = True
message_count = 0


def split_quantities(quantity, per_unit):
    """Splits quantity in units not larger than per_unit.
    
    >>> split_quantities(512.0, 100.0)
    [100, 100, 100, 100, 100, 12]
    >>> split_quantities('512', None)
    [512]
    >>> split_quantities('512.0', 1000)
    [512]
    >>> split_quantities(512, -10)
    [512]
    """
    
    quantity = int(float(quantity))
    if not per_unit or per_unit < 1:
        return [quantity]
    else:
        per_unit = int(float(per_unit))
        ret = []
        while quantity > 0:
            ret.append(min([quantity, per_unit]))
            quantity -= per_unit
        return ret


def _move_units_to_good_location(muis):
    """Moves units to a good location in the warehouse and prints the Palettenfahne
    and the movement-note.
    """
    
    kernel = Kerneladapter()
    movementids = []
    for mui in muis:
        movementids.append((kernel.init_movement_to_good_location(mui), mui))
    for movement_id, mui in movementids:
        if movement_id:
            mypl.models.Movement(movement_id).output_on_printer(printer="DruckerTesler")
        else:
            cs.zwitscher.zwitscher('%s: Kein passender Lagerplatz. Palette verbleibt auf EINLAG #warning' % mui,
                                   username='mypl')


def _umlagerung_to_unit(guid, menge, artnr, batchnr, referenzen):
    """Converts a Umlagerungsposition to an Unit in the Kernel. Returns MUIs generated."""
    
    muis = []
    if menge < 1:
        msg = 'Umlagerung %s hat Positionen ohne Menge (0) fuer %s #warn' % (batchnr, artnr)
        cs.zwitscher.zwitscher(msg, username='mypl')
        print msg.encode('utf-8', 'ignore')
    else:
        # TODO: use cs.masterdata
        product = cs.masterdata.article.eap(artnr)
        msg = None
        if not product:
            msg = u'%s: Kein Artikelpass. Einlagerung abgebrochen. #error' % artnr
        else:
            if not product['palettenfaktor']:
                msg = u'%s: Kein Palettenfaktor. Einlagerung abgebrochen. Übernahme steht #error' % artnr
            if not product['pallet_height']:
                msg = u'%s: Palettenhöhe unbekannt. Einlagerung abgebrochen. Übernahme steht #error' % artnr
            elif product['pallet_height'] > 2100:
                msg = u'%s: Palettenhöhe (%s) zu hoch. Übernahme steht #error' % (artnr,
                            product['pallet_height'])
        
        if msg:
            print msg.encode('utf-8', 'ignore')
            cs.zwitscher.zwitscher(msg, username='mypl')
            return [] # this leaves a stale message
        
        elements = [(quantity, artnr, product['pallet_height']) 
                    for quantity in split_quantities(menge, product['palettenfaktor'])]
        
        referenzen.update({'komminr': str(batchnr), 'source': 'umlagerung'})
        if options.debug:
            print 'kernel.store_at_location_multi%r' % ((guid, "EINLAG", elements, referenzen),)
        kernel = Kerneladapter()
        if not options.dry_run:
            muis = kernel.store_at_location_multi(guid, "EINLAG", elements, referenzen)
    
    if options.debug:
        print muis
    return muis


def decodiere_message(message):
    body = json.loads(message.body)
    return body['guid'], body['menge'], body['artnr'], body['batchnr'], body['referenzen']


def handle_message(message):
    """Callback function used by channel.basic_consume for adding 'Warenzugang' to myPL."""
    global message_count

    message_count += 1
    if message_count > options.maxnum:
        cancel_processing()
        return

    guid, menge, artnr, batchnr, referenzen = decodiere_message(message)
    if options.debug:
        print message_count, guid, menge, artnr, batchnr, referenzen
    # TODO: add logging
    # log_message('nullen', kommibeleg, hugogramm)
    muis = _umlagerung_to_unit(guid, menge, artnr, batchnr, referenzen)
    if muis:
        _move_units_to_good_location(muis)
        channel.basic_ack(message.delivery_tag)


# Might be used as a signal hander
def cancel_processing():
    """ Stop consuming messages from RabbitMQ """
    global process_messages
    
    # Do this so we exit our main loop
    print "Exiting"
    process_messages = False
    # Tell the channel you dont want to consume anymore
    channel.basic_cancel(consumer_tag)


def main():
    """Setup message consuming."""
    global channel, consumer_tag, options

    parser = optparse.OptionParser()
    parser.version = "%%prog" 
    parser.description = ('Uebernimmt Warenzugangsmeldungen aus einer Warteschlange und lagert diese im'
                         + 'myPL ein (EINLAG). Erstellt ausserdem eine Palettenbewegung an einen geeigneten'
                         + 'Platz und  erzeugt eine Palettenfahne.')
    parser.set_usage('usage: %prog [options]')
    parser.add_option('--lager', type="int",
                      help='Lager, dass bearbeitet werden soll')
    parser.add_option('--debug', action='store_true', help='Debugging Informationen ausgeben')
    parser.add_option('--dry-run', action='store_true', help='Keine Daten in PostgreSQL und Kernel')
    parser.add_option('--maxnum', type='int',
                      help='Maximale Anzahl der zu transferierenden Datensaetze [default: unlimited]')

    options, args = parser.parse_args()
    if args:
        parser.error("incorrect number of arguments")
    if not options.lager:
        parser.error("'--lager' nicht gesetzt")

    channel = messaging.setup_queue('erp.ic-wms.warenzugang#%d' % options.lager, durable=True)
    consumer_tag = channel.basic_consume(queue='erp.ic-wms.warenzugang#%d' % options.lager,
                                         callback=handle_message)

    signal.signal(signal.SIGTERM, lambda signum, stack_frame: cancel_processing())
    signal.signal(signal.SIGINT, lambda signum, stack_frame: cancel_processing())

    if options.debug:
        print "waiting for messages ..."
    
    # Loop while process_messages is True - could be set to False by signal handlers
    while process_messages:
        # Wait for a message
        channel.wait()
    
    channel.close()


if __name__ == '__main__':
    main()
