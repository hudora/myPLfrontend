#!/usr/bin/env python
# encoding: utf-8
"""
Uebernimmt Umlagerungsauftraege an Lager 100 aus der Soft-Schnittstelle ISK00 und lagert diese im
'myPL ein (EINLAG). Erstellt ausserdem eine Warenbewegung im myPL an einen geeigneten Platz und
erzeugt eine Palettenfahne.

http://blogs.23.nu/disLEXia/2007/12/antville-16699/ beschreibt die Grundsätze der Kommunikation.

Zusätzlich werden Warenzugangsmeldungen nach
https://cybernetics.hudora.biz/intern/trac/browser/projects/cs/trunk/doc/messaging_ic-wms.rst erzeugt.

Created by Lars Ronge on 2007-12-12.
Rewritten by Maximillian Dornseif 2008-12, 2009-12
Copyright (c) 2007, 2008, 2009 HUDORA GmbH.
"""

__revision__ = "$Revision$"

# From http://superjared.com/entry/django-and-crontab-best-friends/
from django.core.management import setup_environ
import settings
setup_environ(settings)

from husoftm.lagerschnittstelle import ISK00
from husoftm.lieferscheine import kbpos2artnr
from mypl.kernel import Kerneladapter
from mypl.utils import split_quantities
from optparse import OptionParser
import cs.messaging as messaging
import mypl.models
import produktpass.models
import sys
import cs.zwitscher


process_messages = True


parser = OptionParser(version=True)
parser.version = "%%prog %s (mypl.models %s)" % (__revision__.strip('$Revision: '),
                                                   mypl.models.__revision__.strip('$Revision: '))
parser.description = ('Uebernimmt Umlagerungsauftraege als Warenzugangsmeldungen und lagert diese im '
                     + 'myPL ein (EINLAG). Erstellt ausserdem eine Palettenbewegung an einen geeigneten '
                     + 'Platz und  erzeugt eine Palettenfahne.')
parser.set_usage('usage: %prog [options]')
parser.add_option('--debug', action='store_true', help='Debugging Informationen ausgeben')
parser.add_option('--maxnum', type='int',
                  help='Maximum number of rows to trasfer before exiting [defaut: unlimited]')


def _move_units_to_good_location(muis):
    """Moves units to a good location in the warehouse and prints the Palettenfahne
    and the movement-note.
    """
    
    kernel = Kerneladapter()
    movementids = []
    for mui in muis:
        movementids.append((kernel.init_movement_to_good_location(mui), mui))
    for movement_id, mui in movementids:
        if movement_id:
            mypl.models.Movement(movement_id).output_on_printer(printer="DruckerTesler")
        else:
            cs.zwitscher.zwitscher('%s: Kein passender Lagerplatz. Palette verbleibt auf EINLAG #warning' % mui,
                                   username='mypl')


def _umlagerung_to_unit(guid, menge, artnr, batchnr):
    """Converts a Umlagerungsposition to an Unit in the Kernel. Returns MUIs generated."""
    
    if options.debug:
        print guid, menge, artnr, batchnr
    
    muis = []
    if menge < 1:
        if options.debug:
            msg = 'Umlagerung %s hat Positionen ohne Menge (0) fuer %s - interessant ... #warn' % (batchnr, artnr)
            print msg
    else:
        # TODO: use cs.masterdata
        products = produktpass.models.Product.objects.filter(artnr=artnr)
        msg = None
        if not products:
            msg = u'%s: Kein Artikelpass. Einlagerung abgebrochen. #error' % artnr
        else:
            product = products[0]
            if not product.palettenfaktor:
                msg = u'%s: Kein Palettenfaktor. Einlagerung abgebrochen. Übernahme steht #error' % artnr
            if not product.pallet_height:
                msg = u'%s: Palettenhöhe unbekannt. Einlagerung abgebrochen. Übernahme steht #error' % artnr
            elif product.pallet_height > 2100:
                msg = u'%s: Palettenhöhe (%s) zu hoch. Übernahme steht #error' % (artnr,
                            product.pallet_height)
        
        if msg:
            print msg.encode('utf-8', 'ignore')
            cs.zwitscher.zwitscher(msg, username='mypl')
            return [] # this leaves a stale message
        
        uid = "%s-%s" % (komminr, kommipos)
        kernel = Kerneladapter()
        elements = [(quantity, artnr, product.pallet_height) for quantity in split_quantities(menge, product.palettenfaktor)]
        if options.debug:
            print uid, elements
        muis = kernel.store_at_location_multi(uid, "EINLAG", elements, {'komminr': str(komminr),
                                                                        'source': 'umlagerung'})
    
    if options.debug:
        print muis
    return muis

def handle_message(message):
    """Callback function used by channel.basic_consume for adding 'Warenzugang' to myPL."""
    
    guid, menge, artnr, batchnr = decodiere_message(message)
    # TODO: add logging
    # log_message('nullen', kommibeleg, hugogramm)
    muis = _umlagerung_to_unit(guid, menge, artnr, batchnr)
    if muis:
        _move_units_to_good_location(muis)
        channel.basic_ack(message.delivery_tag)
    

# This might go somewhere like a signal handler
def cancel_processing():
    """ Stop consuming messages from RabbitMQ """
    global process_messages
    
    # Do this so we exit our main loop
    print "Exiting"
    process_messages = False
    # Tell the channel you dont want to consume anymore
    channel.basic_cancel(consumer_tag)
    

def main(options):
    """Setum message consuming."""
    global channel, consumer_tag
    
    channel = messaging.setup_queue('erp.cs-wms.warenzugang#100', durable=True)
    
    connection, channel = init_broker()
    consumer_tag = channel.basic_consume(queue = 'erp.cs-wms.warenzugang#100l', callback=handle_message)
    
    signal(SIGTERM, lambda signum, stack_frame: cancel_processing())
    signal(SIGINT, lambda signum, stack_frame: cancel_processing())
    
    if options.debug:
        print "waiting for messages ..."
    
    # Loop while process_messages is True
    while process_messages:
        # Wait for a message
        channel.wait()
    
    channel.close()
    connection.close()
    

options, args = parse_commandline()
if args:
    parser.error("incorrect number of arguments")
main(options)


if __name__ == '__main__':
    main(*parse_commandline())
