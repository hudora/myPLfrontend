#!/usr/bin/env python
# encoding: utf-8
""" ic2wms_wareneingang

Uebernimmt Einlagerungsaufträge an gegebene Lager aus der SoftM-Schnittstelle ISZ00 und
schreibt die als Warenzugangsmeldungen in eine Nachrichtenschlange.

http://blogs.23.nu/disLEXia/2007/12/antville-16699/ beschreibt die Grundsätze der Nutzung
der SoftM Schnittstellen.

Die Warenzugangsmeldungen werden in
http://github.com/hudora/huTools/blob/master/doc/standards/messaging_ic-wms.markdown#readme beschrieben.


Created by Christoph Borgolte on 11-01-2010 for HUDORA.
Copyright (c) 2009 HUDORA. All rights reserved.
"""


if __name__ == "__main__":
    # From http://superjared.com/entry/django-and-crontab-best-friends/
    from django.core.management import setup_environ
    import settings
    setup_environ(settings)


import cs.messaging as messaging
import cs.zwitscher
import huTools.NetStringIO as NetStringIO
import husoftm.warenzugangsschnittstelle
import itertools
import optparse
import simplejson as json
import sys
import time

#from myplfrontend.bin.ic2wms_einlagerungen import display, write_journal


def display(msg):
    """Display messages based on command line options."""
    if options.debug or (not options.quiet):
        print (msg)
        sys.stdout.flush()


def write_journal(doc):
    """Write journal entrys of incoming messages."""
    logdata = json.dumps(doc, sort_keys=True, separators=(',', ':'))
    nstring = NetStringIO.NetStringIO(open(options.log, 'a'))
    nstring.write(logdata)
    nstring.file.close()


def transfer_zugaenge():
    "Handles the transfer of data SoftM/ISZ00 -> messages"

    if options.lager != 100:
        raise RuntimeError("Not impl yet") # TODO das muss noch aus den Bestellungen rausgefummelt werden

    # Hole alle Warenzugangspositionen aus der Schnittstelle
    zugaenge = husoftm.warenzugangsschnittstelle.list_warenzugang()
    positionen = itertools.chain(zugang['bestellpositionen'] for zugang in zugaenge)
    if options.maxnum != None:
        # FIXME: Das bedeutet, dass nicht unbedingt alle Bestellungen voll abgeschickt werden, da diese in
        #        einzelnen Positionen verschickt werden. Vielleicht sollte man das abfragen?
        positionen = itertools.islice(positionen, 0, options.maxnum)

    msgs = []
    for pos in positionen:
        guidbase = "%(bestellnr)s-%(warenvereinnahmungsnr)s" % pos
        batchnr = guidbase
        msg = {"guid": "%s-%s" % (guidbase, pos['bestellpos']),
               "menge": int(float(pos['menge_berechnet'])),
               "artnr": pos['artnr'],
               "batchnr": batchnr,
               "referenzen": {'bestellnr': pos['bestellnr'],
                              'warenvereinnahmungsnr': pos['warenvereinnahmungsnr'],
                              'bestellposnr': pos['bestellpos']}}
        msgs.append(msg)

    # send msges
    outqueuename = '%s#%s' % (options.out_queue, options.lager)
    messaging.setup_queue(outqueuename, durable=True)
    for msg in msgs:
        doc = messaging.empty_message('ic2wms_wareneingang',
                                      audit_trail='import_warenzugang',
                                      audit_info='Auftrag aus SoftM ISZ00')
        doc.update(msg)

        if options.debug:
            display(msg)

        if not options.dry_run:
            # log file for replaying in case of errors
            write_journal(doc)
            messaging.publish(doc, outqueuename)
            messaging.publish(doc, 'log.ic-wms.warenzugang')


def main():
    """main function - option parsing and calling of transfer_umlagerungen()."""

    global options
    parser = optparse.OptionParser()
    parser.description = ('Uebernimmt Einlagerungsauftraege aus der Soft-Schnittstelle ISZ00 '
                          +' und erzeugt Warenzugangsmeldungen')
    parser.set_usage('usage: %prog [options]')
    parser.add_option('--lager', type="int", help='Lager, das bearbeitet werden soll')
    parser.add_option('--out', dest='out_queue', help='Queue to send messages to.')
    parser.add_option('--log', default='/var/log/ic2wms_wareneingang.log',
                      help='Wo sollen die Nachrichten protokolliert werden?')
    parser.add_option('--continuous', action='store_true',
                      help='Run continuously forever')
    parser.add_option('--sleep', type="int", default=47,
                      help='Pause zwischen Durchlaeufen, wenn --continuous verwendet wird [%default s]')
    parser.add_option('--quiet', action='store_true', help='Uebliche Ausgaben unterdruecken')
    parser.add_option('--debug', action='store_true', help='Debugging Informationen ausgeben')
    parser.add_option('--dry-run', action='store_true', help='Keine Daten in PostgreSQL und Kernel')
    parser.add_option('--maxnum', type='int',
                      help='Maximale Anzahl der zu transferierenden Datensaetze [default: unlimited]')

    options, args = parser.parse_args()
    if args:
        parser.error("incorrect number of arguments")
    if not options.lager:
        parser.error("'--lager' nicht gesetzt")
    if not options.out_queue:
        parser.error("'--out' nicht gesetzt")

    display("Starting %r ..." % sys.argv[0])
    while True:
        transfer_zugaenge()
        if not options.continuous:
            break
        time.sleep(options.sleep)
    transfer_zugaenge()
    return 0


if __name__ == "__main__":
    sys.exit(main())
