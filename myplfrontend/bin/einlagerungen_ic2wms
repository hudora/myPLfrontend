#!/usr/bin/env python
# encoding: utf-8
"""Uebernimmt Umlagerungsauftraege an Lager 100 aus der SoftM-Schnittstelle ISK00 und
schreibt die als Warenzugangsmeldungen in eine Nachrichtenschlange.

http://blogs.23.nu/disLEXia/2007/12/antville-16699/ beschreibt die Grundsätze der Nutzung
der SoftM Schnittstellen.

Die Warenzugangsmeldungen werden in
http://github.com/hudora/huTools/blob/master/doc/standards/messaging_ic-wms.markdown#readme beschrieben.

Created by Lars Ronge on 2007-12-12.
Rewritten by Maximillian Dornseif 2008-12 and 2009-12.
Copyright (c) 2007-2010 HUDORA GmbH.
"""

# From http://superjared.com/entry/django-and-crontab-best-friends/
from django.core.management import setup_environ
import settings
setup_environ(settings)

import cs.messaging as messaging
import cs.zwitscher
import huTools.NetStringIO as NetStringIO
import husoftm.lagerschnittstelle
import husoftm.lieferscheine
import husoftm.warenzugangsschnittstelle
import itertools
import optparse
import simplejson as json
import sys


def transfer_umlagerungen():
    "Handles the transfer of data SoftM/ISA00 -> messages"
    
    isk00 = husoftm.lagerschnittstelle.ISK00()
    isk00.clean_stale_locks()
    rows = isk00.available_rows(fields="IKKBNR, IKKPOS, IKRMNG, IKSANR")
    messaging.setup_queue('erp.ic-wms.warenzugang#%d' % options.lager, durable=True)

    rowcounter = 0
    for row in rows:
        komminr, kommiposnr, menge, satznr = row
        artnr, lagernr = husoftm.lieferscheine.kbpos2artnr_zugangslager(komminr, kommiposnr)

        if int(lagernr) != options.lager:
            continue

        rowcounter += 1
        if options.maxnum and (rowcounter > options.maxnum):
            break

        if options.debug:
            print komminr, kommiposnr, menge, satznr, artnr, lagernr

        if menge < 1:
            msg = 'Umlagerung %s hat Positione ohne Menge (0) fuer %s - interessant #warn' % (komminr, artnr)
            cs.zwitscher.zwitscher(msg, username='mypl')
            if options.debug:
                print msg
        else:
            lock_handle = isk00.lock(satznr)
            doc = messaging.empty_message('einlagerungen_ic2wms',
                                          guid="%s-%s" % (komminr, kommiposnr),
                                          audit_trail='import_umlagerungen',
                                          audit_info='Auftrag aus SoftM')
            doc.update(dict(batchnr=komminr,
                            menge=menge,
                            artnr=artnr,
                            referenzen={'kommiposnr': kommiposnr, 'charge': ''}))

            if options.debug:
                print doc

            # log file for replaying in case of errors
            logdata = json.dumps(doc, sort_keys=True, separators=(',',':'))
            nstring = NetStringIO.NetStringIO(open(options.log, 'a'))
            nstring.write(logdata)
            nstring.file.close()

            # FIXME: gehört das nicht auch hinter ein 'if not dry-run:'?
            messaging.publish(doc, 'erp.ic-wms.warenzugang#%d' % options.lager)
            if not options.dry_run:
                isk00.delete(lock_handle)
            isk00.unlock(lock_handle)


def transfer_zugaenge():
    "Handles the transfer of data SoftM/ISZ00 -> messages"
    # Hier werden nur Warenzugänge für Lager 100 (ISZ00) behandelt
    if options.lager != 100:
        return

    # Hole alle Warenzugangspositionen aus der Schnittstelle
    zugaenge = husoftm.warenzugangsschnittstelle.list_warenzugang()
    positionen = itertools.chain(zugang['bestellpositionen'] for zugang in zugaenge)
    if options.maxnum != None:
        # FIXME: Das bedeutet, dass nicht unbedingt alle Bestellungen voll abgeschickt werden, das diese in
        #        einzelnen Positionen verschickt werden. Vielleicht sollte man das abfragen?
        #        Ausserdem müsste man noch vergleichen, wieviele positionen bereits von transfer_umlagerungen
        #        verschickt wurden!
        positionen = itertools.islice(positionen, 0, options.maxnum)

    msgs = []
    for pos in positionen:
        guidbase = "%(bestellnr)s-%(warenvereinnahmungsnr)s" % pos
        batchnr = guidbase
        msg = {"guid": "%s-%s" % (guidbase, pos['bestellpos']),
               "menge": int(float(pos['menge_berechnet'])),
               "artnr": pos['artnr'],
               "batchnr": batchnr}
        msgs.append(msg)

    # send msges
    # TODO: Kombinieren mit transfer_umlagerungen (-> refactoring, da ähnliches Vorgehen in beiden funcs)
    qname = 'erp.ic-wms.warenzugang#%d' % options.lager
    messaging.setup_queue(qname, durable=True)
    for msg in msgs:
        doc = messaging.empty_message('einlagerungen_ic2wms',
                                      audit_trail='import_warenzugang',
                                      audit_info='Auftrag aus SoftM')
        doc.update(msg)

        if options.debug:
            print doc

        # log file for replaying in case of errors
        logdata = json.dumps(doc, sort_keys=True, separators=(',', ':'))
        nstring = NetStringIO.NetStringIO(open(options.log, 'a'))
        nstring.write(logdata)
        nstring.file.close()

        # FIXME: gehört das nicht auch hinter ein 'if not dry-run:'?
        messaging.publish(doc, qname)


def main():
    """main function - option parsing and calling of transfer_umlagerungen()."""

    global options
    parser = optparse.OptionParser()
    parser.description = ('Uebernimmt Umlagerungsauftraege aus der Soft-Schnittstelle ISK00 und '
                         + 'erzeugt Warenzugangsmeldungen')
    parser.set_usage('usage: %prog [options]')
    parser.add_option('--lager', type="int",
                      help='Lager, das bearbeitet werden soll')
    parser.add_option('--log', default='/var/log/ic2wms_einlagerungen.log',
                      help='Wo sollen die Nachrichten protokolliert werden?')
    parser.add_option('--dry-run', action='store_true', help='Keine Daten in PostgreSQL und Kernel')
    parser.add_option('--debug', action='store_true', help='Debugging Informationen ausgeben')
    parser.add_option('--maxnum', type='int',
                      help='Maximale Anzahl der zu transferierenden Datensaetze [default: unlimited]')

    options, args = parser.parse_args()
    if args:
        parser.error("incorrect number of arguments")
    if not options.lager:
        parser.error("'--lager' nicht gesetzt")
    
    transfer_umlagerungen()
    return 0


if __name__ == "__main__":
    sys.exit(main())
