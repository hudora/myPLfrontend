#!/usr/bin/env python
# encoding: utf-8
"""
Uebernimmt Warenzugangsmeldungen für Lager 100 aus einer Nachrichtenschlange und lagert diese im
myPL ein (EINLAG). Erstellt ausserdem eine Warenbewegung im myPL an einen geeigneten Platz und
erzeugt eine Palettenfahne.

Created by Lars Ronge on 2007-12-12.
Rewritten by Maximillian Dornseif 2008-12, 2009-12
Copyright (c) 2007-2010 HUDORA GmbH.
"""

import cs.masterdata.article
import cs.messaging
from cs.messaging.journal import write_journal
import cs.printing
import cs.zwitscher

import myplfrontend.belege
from myplfrontend.kernelapi import Kerneladapter
from myplfrontend.tools import split_quantities
import optparse
import signal
import sys
import time
import logging

LOGGER = logging.getLogger("myplfrontend.wms2mypl_umlagerung")
process_messages = True
message_count = 0


def move_units_to_good_location(muis):
    """Moves units to a good location in the warehouse and prints the Palettenfahne
    and the movement-note.
    """

    kernel = Kerneladapter()
    movementids = []
    for mui in muis:
        movementids.append((kernel.init_movement_to_good_location(mui), mui))
    
    for movement_id, mui in movementids:
        if movement_id:
            # Umlagerbeleg drucken
            pdf = myplfrontend.belege.get_movement_pdf(movement_id)
            cs.printing.print_data(pdf, printer="DruckerTesler")
        else:
            cs.zwitscher.zwitscher('%s: Kein passender Lagerplatz. Palette bleibt auf EINLAG #warning' % mui,
                                   username='mypl')


def umlagerung_to_unit(guid, menge, artnr, batchnr, referenzen):
    """Converts a Umlagerungsposition to a Unit in the Kernel. Returns MUIs generated."""

    muis = []
    
    if menge < 1:
        msg = 'Umlagerung %s hat Position ohne Menge (0) fuer %s #warn' % (batchnr, artnr)
        cs.zwitscher.zwitscher(msg, username='mypl')
        LOGGER.error(msg)
        return None # this leaves a stale message

    product = cs.masterdata.article.eap(artnr)
    msg = None
    if not product:
        msg = u'%s: Kein Artikelpass. Einlagerung abgebrochen. #error' % artnr
    else:
        if not product.get('palettenfaktor'):
            msg = u'%s: Kein Palettenfaktor. Einlagerung abgebrochen. Übernahme steht #error' % artnr
        if not product.get('pallet_height'):
            msg = u'%s: Palettenhöhe unbekannt. Einlagerung abgebrochen. Übernahme steht #error' % artnr
        elif product.get('pallet_height', 1950) > 2100:
            msg = u'%s: Palettenhöhe (%s) zu hoch. Übernahme steht #error' % (artnr,
                        product['pallet_height'])

    if msg:
        msg = "%s/%s" % (guid, msg)
        cs.zwitscher.zwitscher(msg, username='mypl')
        LOGGER.error(msg)
        return None # this leaves a stale message

    # Einlagerung auf Paletten aufteilen
    elements = [(quantity, artnr, product['pallet_height'])
                for quantity in split_quantities(menge, product['palettenfaktor'])]
    referenzen.update({'komminr': str(batchnr), 'source': 'umlagerung', 'paletten': len(elements)})

    kernel = Kerneladapter()
    if not options.dry_run:
        # TODO: move to new HTTP-API
        # mypl.kernel.mypl_kerneladapter.KernelError: error during storing of [(126, '76404', 1850)]: ['error', 'duplicate_id', '3106032-19']
        try:
            muis = kernel.store_at_location_multi(guid, "EINLAG", elements, referenzen)
            doc = cs.messaging.empty_message('wms2mypl_einlagerungen',
                                             guid=guid,
                                             audit_trail='wms2mypl_einlagerungen',
                                             audit_info='Auftrag aus SoftM in Kernel geschrieben')
            doc.update({'to_location': "EINLAG", 'elements': elements, 'referenzen': referenzen, 'muis': muis})
            write_journal(doc, options.log)
            cs.messaging.publish(doc, 'log.wms-mypl.warenzugang')
        except mypl.kernel.mypl_kerneladapter.KernelError, msg:
            if "'error', 'duplicate_id'" in str(msg):
                msg = 'Umlagerung %s kommt doppelt im myPL vor #warn' % batchnr
                cs.zwitscher.zwitscher(msg, username='mypl')
                print msg
                return []
            else:
                raise

    LOGGER.debug("%r" % muis)
    return muis


def handle_message(message):
    """Callback function used by channel.basic_consume for adding 'Warenzugang' to myPL."""
    global message_count

    if options.maxnum and (message_count > options.maxnum):
        cancel_processing()
        return

    body = cs.messaging.decode(message.body)
    guid, menge, artnr = body['guid'], body['menge'], body['artnr']
    batchnr, referenzen = body['batchnr'], body['referenzen']
    
    LOGGER.debug(", ".join((message_count, guid, menge, artnr, batchnr, referenzen)))
    
    # umlagerung_to_unit() macht die wirkliche arbeit und überträgt in den kernel.
    muis = umlagerung_to_unit(guid, menge, artnr, batchnr, referenzen)
    if not muis is None:
        channel.basic_ack(message.delivery_tag)
        # Wenn wir move_units_to_good_location() nicht aufrufen, kümmert sich der Kernel später selbst
        # um das wegräumen der Paletten, wir sind also im grunde längst fertig.
        if not options.no_movements:
            move_units_to_good_location(muis)
        message_count += 1


# Might be used as a signal hander
def cancel_processing():
    """ Stop consuming messages from RabbitMQ """
    global process_messages

    # Do this so we exit our main loop
    process_messages = False
    LOGGER.info("Exiting")
    # Tell the channel you dont want to consume anymore
    for consumer_tag in consumer_tags:
        channel.basic_cancel(consumer_tag)


def main():
    """Setup message consuming."""
    global channel, consumer_tags, options
    consumer_tags = []

    parser = optparse.OptionParser()
    parser.version = "%%prog"
    parser.description = ('Uebernimmt Warenzugangsmeldungen aus einer Warteschlange und lagert diese im'
                         + 'myPL ein (EINLAG). Erstellt ausserdem eine Palettenbewegung an einen geeigneten'
                         + 'Platz und  erzeugt eine Palettenfahne.')
    parser.set_usage('usage: %prog [options]')
    parser.add_option('--lager', type="int", help='Lager, das bearbeitet werden soll')
    parser.add_option('--in', dest="in_queues", action='append',
                      help='Name der Queue, aus der gelesen werden soll. Wird diese Parameter mehrfach '
                      +'angegeben, wird aus mehreren Queues gelesen. Beispiel --in=erp.ic-wms.warenzugang.')
    parser.add_option('--log', default='/var/log/wms2mypl_einlagerungen.log',
                      help='Wo sollen die Nachrichten protokolliert werden? [%default]')
    parser.add_option('--quiet', action='store_true', help='Uebliche Ausgaben unterdruecken')
    parser.add_option('--debug', action='store_true', help='Debugging Informationen ausgeben')
    parser.add_option('--dry-run', action='store_true', help='Keine Nachrichten absenden und loeschen')
    parser.add_option('--no-movements', action='store_true', help='Palleten NICHT von EINLAG weglagern.')
    parser.add_option('--maxnum', type='int',
                      help='Maximale Anzahl der zu transferierenden Datensaetze [default: unlimited]')

    options, args = parser.parse_args()
    if args:
        parser.error("incorrect number of arguments")
    if not options.lager:
        parser.error("'--lager' nicht gesetzt")
    if not options.in_queues:
        parser.error("'--in' nicht gesetzt")

    if options.debug:
        LOGGER.setLevel(logging.DEBUG)
    elif options.quiet:
        LOGGER.setLevel(logging.ERROR)
    else:
        LOGGER.setLevel(logging.INFO)

    channel = None
    for qname in options.in_queues:
        inqueuename = "%s#%s" % (qname, options.lager)
        channel = cs.messaging.setup_queue(inqueuename, channel=channel, durable=True)
        consumer_tags.append(channel.basic_consume(queue=inqueuename, callback=handle_message))

    # Install signal handlers
    signal.signal(signal.SIGTERM, lambda signum, stack_frame: cancel_processing())
    signal.signal(signal.SIGINT, lambda signum, stack_frame: cancel_processing())

    LOGGER.info("waiting for messages ...")

    # Loop while process_messages is True - could be set to False by signal handlers
    last_requeue = time.time()
    while process_messages:
        # Wait for a message and wait for `handle_message` callback beeing called
        channel.wait()
        if time.time() - last_requeue > 3600:
            # every 3600 seconds Request non-acknowledged messages to be re-delivered
            channel.basic_recover(requeue=True)
            last_requeue = time.time()

    channel.close()
    return 0


if __name__ == '__main__':
    sys.exit(main())
